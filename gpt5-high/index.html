<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>MAGNETRON â€” Neon Survivor</title>
<style>
  :root{
    --bg:#070a12;
    --ink:#cde6ff;
    --ink-dim:#7fa2c9;
    --green:#5effb3;
    --cyan:#65c7ff;
    --blue:#5990ff;
    --purple:#a57bff;
    --pink:#ff5ac9;
    --red:#ff5f74;
    --gold:#ffdf6e;
    --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%;background:radial-gradient(1200px 900px at 20% 20%, #0e1630 0%, #0a0f21 40%, var(--bg) 100%);
    color:var(--ink);font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; margin:0; overflow:hidden; -webkit-touch-callout:none; -webkit-user-select:none; user-select:none;}
  canvas{position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none;}
  /* HUD */
  #hud{position:fixed; inset:0; pointer-events:none; padding:10px;}
  #hud .row{display:flex; align-items:center; justify-content:space-between; gap:10px;}
  #hud .left, #hud .center, #hud .right{display:flex; align-items:center; gap:10px;}
  #hearts{display:flex; gap:6px; filter:drop-shadow(0 0 6px rgba(255,73,109,.4));}
  .heart{width:18px; height:16px; position:relative;}
  .heart::before, .heart::after{content:""; position:absolute; width:10px; height:16px; background:linear-gradient(#ff9eae, var(--red)); border-radius:10px 10px 0 0; left:4px; top:0; box-shadow:0 0 10px rgba(255,96,112,.5) inset;}
  .heart::after{transform:rotate(-45deg); transform-origin:5px 10px;}
  .heart::before{transform:rotate(45deg); transform-origin:5px 10px; left:-2px;}
  .bar{width:min(44vw,520px); height:10px; background:rgba(255,255,255,.06); border-radius:20px; overflow:hidden; position:relative; box-shadow:inset 0 0 15px rgba(0,0,0,.3); border:1px solid rgba(255,255,255,.04)}
  .bar.small{width:min(44vw,360px); height:8px;}
  .bar .fill{height:100%; width:0%; background:linear-gradient(90deg, #3ef3ff, #59ffa6); box-shadow:0 0 20px rgba(79,255,196,.45)}
  .bar.energy .fill{background:linear-gradient(90deg, var(--cyan), var(--green));}
  .bar.xp{height:6px; opacity:.85}
  .bar.xp .fill{background:linear-gradient(90deg, var(--purple), var(--pink)); box-shadow:0 0 18px rgba(217,130,255,.4);}
  #scoreWrap{display:flex; flex-direction:column; align-items:flex-end; gap:6px; text-shadow:0 0 10px rgba(255,255,255,.08);}
  #score{font-size:24px; font-weight:800; letter-spacing:.5px;}
  #mult{font-size:12px; color:var(--ink-dim)}
  #wave{font-size:12px; color:var(--ink-dim)}
  #hint{position:fixed; bottom:8px; left:50%; transform:translateX(-50%); font-size:12px; color:#9fbad9; text-align:center; opacity:.85}
  /* overlays */
  .overlay{position:fixed; inset:0; display:none; align-items:center; justify-content:center; backdrop-filter:blur(10px); background:radial-gradient(800px 600px at 50% 30%, rgba(74,108,255,.08), rgba(0,0,0,.35));}
  .overlay.show{display:flex;}
  .card{background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)); border:1px solid rgba(255,255,255,.12); border-radius:16px; padding:18px 20px; box-shadow:var(--shadow); color:var(--ink); }
  h1{margin:0 0 8px 0; font-size:34px; letter-spacing:1.5px; line-height:1.1; text-shadow:0 0 16px rgba(128,180,255,.3)}
  .titleSub{opacity:.8; font-size:13px; margin-bottom:12px}
  .btnRow{display:flex; gap:12px; flex-wrap:wrap; justify-content:center; margin-top:14px}
  .btn{cursor:pointer; background:linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06)); border:1px solid rgba(255,255,255,.18); color:var(--ink); padding:10px 14px; border-radius:12px; font-weight:700; letter-spacing:.3px; transition:.15s transform ease, .15s background ease; box-shadow:var(--shadow);}
  .btn:hover{transform:translateY(-1px); background:linear-gradient(180deg, rgba(255,255,255,.16), rgba(255,255,255,.08));}
  .btn.primary{background:linear-gradient(180deg, #4f8bff, #3e6bff); border-color:#6aa1ff; color:white; text-shadow:0 1px 6px rgba(0,0,0,.3)}
  .btn.accent{background:linear-gradient(180deg, #ff3b7b, #fe2d56); border-color:#ff7aa4; color:white}
  .btn.ghost{background:transparent; border:1px dashed rgba(255,255,255,.25)}
  .split{display:flex; gap:14px; align-items:stretch; flex-wrap:wrap; justify-content:center}
  .choice{width:min(280px, 80vw); cursor:pointer; position:relative;}
  .choice .ico{font-size:26px; margin-bottom:8px}
  .choice .name{font-weight:900; letter-spacing:.4px; margin-bottom:6px}
  .choice .desc{opacity:.9; font-size:14px; min-height:36px}
  .choice .levels{position:absolute; top:12px; right:12px; font-size:12px; color:#cfe0ff; opacity:.75}
  .metaRow{display:grid; grid-template-columns:1fr auto auto; gap:8px; align-items:center; margin:8px 0}
  .pill{padding:4px 8px; border-radius:999px; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.15); font-size:12px}
  .cost{color:var(--gold); font-weight:900}
  .small{font-size:12px; opacity:.9}
  /* touch controls */
  #touch{position:fixed; inset:0; pointer-events:none;}
  .tBtn{position:absolute; right:16px; bottom:16px; width:88px; height:88px; border-radius:50%; background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.35), rgba(255,255,255,.08)); border:1px solid rgba(255,255,255,.2); box-shadow:0 10px 30px rgba(0,0,0,.4), inset 0 0 22px rgba(255,255,255,.2); pointer-events:auto; display:grid; place-items:center; color:white; font-weight:900; text-shadow:0 1px 6px rgba(0,0,0,.35)}
  #attractBtn{right:16px; bottom:16px;}
  #pulseBtn{right:116px; bottom:24px; width:72px; height:72px;}
  @media (hover: none) and (pointer: coarse){
    #hint{display:none}
  }
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
  <div class="row">
    <div class="left">
      <div id="hearts"></div>
      <div id="wave" class="pill">Wave 1</div>
    </div>
    <div class="center" style="flex:1; justify-content:center; gap:10px; flex-direction:column;">
      <div class="bar energy small"><div class="fill" id="energyFill"></div></div>
      <div class="bar xp"><div class="fill" id="xpFill"></div></div>
    </div>
    <div class="right">
      <div id="scoreWrap">
        <div id="score">0</div>
        <div id="mult">x1.0 Combo</div>
      </div>
    </div>
  </div>
</div>

<div id="menu" class="overlay show">
  <div class="card" style="max-width:min(760px,92vw);">
    <h1>MAGNETRON</h1>
    <div class="titleSub">Neon Survivor â€” Orbit, Attract, Pulse. Build absurd combos in a glowing arena.</div>
    <div class="split" style="margin-top:6px">
      <div class="card" style="min-width:260px;">
        <div style="font-weight:900; letter-spacing:.5px; margin-bottom:6px">How to Play</div>
        <div class="small">
          â€¢ Move: WASD / Arrow Keys (or drag finger to move)<br>
          â€¢ Attract: Hold Left Mouse / Hold ATTRACT button<br>
          â€¢ Pulse: Space / Right Click / PULSE button<br>
          â€¢ Collect shards to score and level up. Attracting pulls enemies tooâ€”risk vs reward! Choose upgrades every level. Survive as long as you can.
        </div>
        <div class="small" style="margin-top:8px; opacity:.9">Tip: Quick consecutive pickups raise your combo multiplier. Pulse to clear space when surrounded.</div>
      </div>
      <div class="card" style="min-width:260px;">
        <div style="font-weight:900; letter-spacing:.5px; margin-bottom:6px">Run Stats</div>
        <div class="small">Best Score: <span id="bestScore">0</span></div>
        <div class="small">Lifetime Cores: <span id="coresTotal">0</span></div>
        <div class="btnRow" style="margin-top:10px">
          <div id="startBtn" class="btn primary">Play</div>
          <div id="metaBtn" class="btn">Meta Lab</div>
          <div id="soundBtn" class="btn ghost">Sound: On</div>
        </div>
      </div>
    </div>
    <div style="margin-top:10px; text-align:center; font-size:12px; opacity:.8">All in one file. No downloads. Enjoy!</div>
  </div>
</div>

<div id="levelup" class="overlay">
  <div class="card" style="max-width:min(980px, 96vw);">
    <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom:8px">
      <div style="font-weight:900; letter-spacing:.8px">Choose an Upgrade</div>
      <div id="rerollWrap" class="pill small">Rerolls: <span id="rerolls">0</span> â€¢ <span id="rerollBtn" class="btn" style="padding:4px 8px; border-radius:8px; margin-left:8px;">Reroll</span></div>
    </div>
    <div id="choices" class="split"></div>
  </div>
</div>

<div id="gameover" class="overlay">
  <div class="card" style="max-width:min(640px, 92vw); text-align:center">
    <div style="font-size:28px; font-weight:900; margin-bottom:10px; letter-spacing:1px">Run Over</div>
    <div id="finalScore" style="font-size:40px; font-weight:900; color:#fff; text-shadow:0 0 20px rgba(255,255,255,.2)">0</div>
    <div style="margin-top:10px; display:flex; justify-content:center; gap:18px; flex-wrap:wrap">
      <div class="pill">Best: <span id="finalBest">0</span></div>
      <div class="pill">Cores gained: <span id="finalCoresGain">0</span></div>
      <div class="pill">Lifetime Cores: <span id="finalCores">0</span></div>
    </div>
    <div class="btnRow">
      <div id="retryBtn" class="btn primary">Run it Back</div>
      <div id="toMenuBtn" class="btn">Main Menu</div>
      <div id="toMetaBtn" class="btn ghost">Meta Lab</div>
    </div>
  </div>
</div>

<div id="metalab" class="overlay">
  <div class="card" style="max-width:min(720px, 94vw);">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px">
      <div style="font-weight:900; letter-spacing:.8px;">Meta Lab â€” Spend Cores</div>
      <div class="pill">Cores: <span id="mCores">0</span></div>
    </div>
    <div id="metaList"></div>
    <div class="btnRow">
      <div id="metaClose" class="btn">Close</div>
      <div id="metaReset" class="btn ghost">Reset Meta</div>
    </div>
  </div>
</div>

<div id="touch">
  <div id="attractBtn" class="tBtn">ATTRACT</div>
  <div id="pulseBtn" class="tBtn">PULSE</div>
</div>

<div id="hint">Esc: Pause â€¢ M: Toggle sound</div>

<script>
(() => {
  // ------- Canvas/Context Setup -------
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  let W=0,H=0, CX=0, CY=0;
  function resize(){
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    W = Math.floor(window.innerWidth);
    H = Math.floor(window.innerHeight);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W+'px';
    canvas.style.height = H+'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    CX=W/2; CY=H/2;
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ------- Simple RNG -------
  let seed = (Math.random()*1e9)|0;
  const rand = () => (seed = (seed*1664525+1013904223)|0, ((seed>>>0)/4294967296));

  // ------- Audio -------
  let AudioCtx = null;
  const SFX = {
    enabled:true,
    init(){
      if(AudioCtx) return;
      AudioCtx = new (window.AudioContext||window.webkitAudioContext)();
      this.master = AudioCtx.createGain();
      this.master.gain.value = 0.25;
      // mild compression for punch
      const comp = AudioCtx.createDynamicsCompressor();
      comp.threshold.setValueAtTime(-18, AudioCtx.currentTime);
      comp.knee.setValueAtTime(24, AudioCtx.currentTime);
      comp.ratio.setValueAtTime(4, AudioCtx.currentTime);
      comp.attack.setValueAtTime(0.003, AudioCtx.currentTime);
      comp.release.setValueAtTime(0.1, AudioCtx.currentTime);
      this.master.connect(comp);
      comp.connect(AudioCtx.destination);
    },
    now(){ return AudioCtx ? AudioCtx.currentTime : 0; },
    osc({type='sine', freq=440, dur=0.08, vol=0.2, slide=0}={}){
      if(!AudioCtx || !this.enabled) return;
      const t = this.now();
      const o = AudioCtx.createOscillator();
      const g = AudioCtx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t);
      if(slide) o.frequency.exponentialRampToValueAtTime(Math.max(1,freq*slide), t+dur*0.9);
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(vol, t+0.002);
      g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
      o.connect(g); g.connect(this.master);
      o.start(t);
      o.stop(t+dur+0.02);
    },
    noise({dur=0.15, vol=0.2, type='white'}={}){
      if(!AudioCtx || !this.enabled) return;
      const t = this.now();
      const bs = AudioCtx.sampleRate*dur|0;
      const buf = AudioCtx.createBuffer(1, bs, AudioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for(let i=0;i<bs;i++){
        let n = Math.random()*2-1;
        if(type==='pink'){ n = (Math.random()+Math.random()+Math.random()+Math.random()+Math.random()+Math.random())/6*2-1; }
        data[i]=n*0.9;
      }
      const src = AudioCtx.createBufferSource();
      src.buffer = buf;
      const g = AudioCtx.createGain();
      g.gain.setValueAtTime(0, t);
      g.gain.linearRampToValueAtTime(vol, t+0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
      src.connect(g); g.connect(this.master);
      src.start(t); src.stop(t+dur+0.05);
    },
    pickup(){ this.osc({type:'triangle', freq: 700+rand()*200, dur:0.07, vol:0.15, slide:1.6}); },
    pulse(){ this.osc({type:'sine', freq: 120, dur:0.3, vol:0.35, slide:0.6}); this.noise({dur:0.15, vol:0.2}); },
    hit(){ this.osc({type:'square', freq: 180, dur:0.12, vol:0.25, slide:0.4}); this.noise({dur:0.08, vol:0.15}); },
    level(){ this.osc({type:'sine', freq:640, dur:0.12, vol:0.15}); this.osc({type:'sine', freq:820, dur:0.14, vol:0.12}); },
    select(){ this.osc({type:'triangle', freq:500, dur:0.08, vol:0.14}); },
    deny(){ this.osc({type:'square', freq:120, dur:0.08, vol:0.12}); },
  };

  // ------- DOM Elements -------
  const $ = sel => document.querySelector(sel);
  const menu = $('#menu'), levelup = $('#levelup'), gameover = $('#gameover'), metalab = $('#metalab');
  const startBtn = $('#startBtn'), metaBtn = $('#metaBtn'), soundBtn = $('#soundBtn');
  const retryBtn = $('#retryBtn'), toMenuBtn = $('#toMenuBtn'), toMetaBtn = $('#toMetaBtn');
  const energyFill = $('#energyFill'), xpFill = $('#xpFill');
  const heartsEl = $('#hearts'), scoreEl = $('#score'), multEl = $('#mult'), waveEl = $('#wave');
  const bestScoreEl = $('#bestScore'), coresTotalEl = $('#coresTotal');
  const finalScoreEl = $('#finalScore'), finalBestEl = $('#finalBest'), finalCoresGainEl = $('#finalCoresGain'), finalCoresEl = $('#finalCores');
  const choicesEl = $('#choices'), rerollsEl = $('#rerolls'), rerollBtn = $('#rerollBtn'), rerollWrap = $('#rerollWrap');
  const mCoresEl = $('#mCores'), metaList = $('#metaList'), metaClose = $('#metaClose'), metaReset = $('#metaReset');
  const attractBtn = $('#attractBtn'), pulseBtn = $('#pulseBtn');

  // ------- Game State -------
  const G = {
    state:'menu',
    t:0, last:0, dt:0, timescale:1,
    score:0, best: +localStorage.getItem('mag_best')||0,
    combo:1, comboTimer:0, wave:1,
    entities: {enemies:[], shards:[], parts:[], pulses:[], drones:[]},
    input: {keys:{}, mouse:{x:0,y:0, left:false, right:false}, touchMoveTarget:null, attract:false, pulse:false},
    spawn: {enemyTimer:0, shardTimer:0, waveTime:0, difficulty:0},
    paused:false, canStep:true, seed:0,
  };

  // ------- Meta Progression -------
  const META = {
    data: JSON.parse(localStorage.getItem('mag_meta')||'{"cores":0,"upgrades":{"hp":0,"regen":0,"mag":0,"reroll":0}}'),
    save(){ localStorage.setItem('mag_meta', JSON.stringify(this.data)); },
    reset(){ this.data={cores:0, upgrades:{hp:0,regen:0,mag:0,reroll:0}}; this.save(); renderMeta(); },
    costs: { hp:[20,40,80,140,220], regen:[10,20,40,70,120], mag:[10,20,40,70,120], reroll:[30,60,120] },
    max: { hp:5, regen:5, mag:5, reroll:3 },
    names: { hp:"+1 Max HP", regen:"+10% Energy Regen", mag:"+10% Magnet Radius", reroll:"+1 Reroll per Run" },
  };

  function renderMeta(){
    mCoresEl.textContent = META.data.cores|0;
    metaList.innerHTML = '';
    const mkRow = (key) => {
      const lvl = META.data.upgrades[key]||0;
      const max = META.max[key];
      const cost = META.costs[key][lvl] || 'â€”';
      const row = document.createElement('div');
      row.className='metaRow';
      row.innerHTML = `
        <div><b>${META.names[key]}</b> <span class="small">Level ${lvl}/${max}</span></div>
        <div class="cost">${(lvl>=max)?'MAX':(cost+'â—ˆ')}</div>
        <div>${(lvl>=max)?'<span class="btn ghost">Maxed</span>': '<span class="btn buyBtn" data-key="'+key+'">Buy</span>'}</div>
      `;
      return row;
    };
    metaList.appendChild(mkRow('hp'));
    metaList.appendChild(mkRow('regen'));
    metaList.appendChild(mkRow('mag'));
    metaList.appendChild(mkRow('reroll'));
    metaList.querySelectorAll('.buyBtn').forEach(btn=>{
      btn.addEventListener('click',()=>{
        const key = btn.getAttribute('data-key');
        const lvl = META.data.upgrades[key]||0;
        const cost = META.costs[key][lvl];
        if(lvl >= META.max[key]) { SFX.deny(); return;}
        if((META.data.cores|0) >= cost){
          META.data.cores -= cost;
          META.data.upgrades[key] = lvl+1;
          META.save(); SFX.select(); renderMeta();
          // also reflect on menu
          updateMenuStats();
        }else{
          SFX.deny();
        }
      });
    });
  }

  function updateMenuStats(){
    bestScoreEl.textContent = G.best|0;
    coresTotalEl.textContent = META.data.cores|0;
    soundBtn.textContent = 'Sound: ' + (SFX.enabled?'On':'Off');
  }

  // ------- Player / Entities -------
  const Player = {
    reset(){
      const u = META.data.upgrades;
      this.x=CX; this.y=CY; this.vx=0; this.vy=0;
      this.r=12;
      this.baseSpeed=220; this.speed = this.baseSpeed;
      this.fric=0.86;
      this.maxHp=3 + (u.hp||0); this.hp=this.maxHp; this.invul=0;
      this.maxEnergy=100; this.energy=this.maxEnergy;
      this.energyRegen = 22 * (1 + 0.10*(u.regen||0));
      this.magnetR = 140 * (1 + 0.10*(u.mag||0));
      this.magnetForce = 560;
      this.pulseRadius = 160;
      this.pulsePower = 380;
      this.pulseCost = 30;
      this.pulseCd = 1.6;
      this.pulseTimer = 0;
      this.xp=0; this.toNext=20; this.level=1;
      this.healChance=0; this.hasSlow=false; this.slowStrength=0; this.slowTimer=0;
      this.shield=0; this.shieldMax=0; this.shieldTimer=0; this.shieldCd=18;
      this.drones=0;
      this.rerolls = (META.data.upgrades.reroll||0);
      // upgrades map
      this.upg = {};
    },
    addUpgrade(id){
      this.upg[id]=(this.upg[id]||0)+1;
    }
  };

  const UPGRADE_POOL = [
    {id:'magR', name:'Wider Magnet', icon:'ðŸ§²', max:6, desc:()=>`Magnet radius +15%`, apply:p=>{p.magnetR*=1.15;}},
    {id:'magF', name:'Stronger Pull', icon:'ðŸŒ€', max:6, desc:()=>`Magnet force +20%`, apply:p=>{p.magnetForce*=1.2;}},
    {id:'energy', name:'Voltaic Reactor', icon:'âš¡', max:6, desc:()=>`Energy regen +25%`, apply:p=>{p.energyRegen*=1.25;}},
    {id:'battery', name:'Bigger Battery', icon:'ðŸ”‹', max:4, desc:()=>`Max energy +25`, apply:p=>{p.maxEnergy+=25; p.energy+=25;}},
    {id:'pulseR', name:'Pulse Radius', icon:'ðŸŒ', max:6, desc:()=>`Pulse radius +15%`, apply:p=>{p.pulseRadius*=1.15;}},
    {id:'pulseP', name:'Pulse Power', icon:'ðŸ’¥', max:5, desc:()=>`Pulse power +20%`, apply:p=>{p.pulsePower*=1.2;}},
    {id:'pulseC', name:'Pulse Cooldown', icon:'â±ï¸', max:4, desc:()=>`Pulse cooldown -12%`, apply:p=>{p.pulseCd*=0.88;}},
    {id:'speed', name:'Thrusters', icon:'ðŸ§­', max:6, desc:()=>`Move speed +12%`, apply:p=>{p.speed*=1.12; p.baseSpeed*=1.12;}},
    {id:'shield', name:'Kinetic Shield', icon:'ðŸ›¡ï¸', max:3, desc:()=>`+1 auto-recharging shield`, apply:p=>{p.shieldMax++; p.shield=p.shieldMax;}},
    {id:'drone', name:'Collector Drone', icon:'ðŸ”¸', max:3, desc:()=>`+1 orbiting collector`, apply:p=>{p.drones++; spawnDrone();}},
    {id:'timeslow', name:'Time Dilation', icon:'â³', max:2, desc:()=>`Near-miss slows time briefly`, apply:p=>{p.hasSlow=true; p.slowStrength+=0.5;}},
    {id:'heal', name:'Leech', icon:'ðŸ’š', max:3, desc:()=>`10% chance pickups heal 1`, apply:p=>{p.healChance+=0.10;}},
  ];

  function pickUpgrades(n=3){
    const choices = [];
    const attempts = 16;
    let tries=0;
    const notMaxed = UPGRADE_POOL.filter(u => (Player.upg[u.id]||0) < u.max);
    if(notMaxed.length<=n) return [...notMaxed];
    while(choices.length<n && tries<attempts){
      tries++;
      const u = notMaxed[(rand()*notMaxed.length)|0];
      if(!choices.includes(u)) choices.push(u);
    }
    while(choices.length<n){
      const u = notMaxed[(rand()*notMaxed.length)|0];
      if(!choices.includes(u)) choices.push(u);
    }
    return choices;
  }

  function showLevelUp(){
    if(G.state!=='playing') return;
    G.state='levelup';
    SFX.level();
    const opts = pickUpgrades(3);
    renderChoices(opts);
    levelup.classList.add('show');
    rerollsEl.textContent = Player.rerolls|0;
    rerollWrap.style.display = 'flex';
    if((Player.rerolls|0)<=0) rerollWrap.style.display = 'none';
  }

  function renderChoices(options){
    choicesEl.innerHTML = '';
    options.forEach(opt=>{
      const card = document.createElement('div');
      card.className='choice card';
      const lvl = Player.upg[opt.id]||0;
      card.innerHTML = `
        <div class="ico">${opt.icon}</div>
        <div class="name">${opt.name}</div>
        <div class="desc">${opt.desc(Player)}</div>
        <div class="levels">Lvl ${lvl}/${opt.max}</div>
      `;
      card.addEventListener('click', ()=>{
        opt.apply(Player); Player.addUpgrade(opt.id); SFX.select();
        levelup.classList.remove('show'); G.state='playing';
      });
      choicesEl.appendChild(card);
    });
    rerollBtn.onclick = ()=>{
      if(Player.rerolls>0){
        Player.rerolls--; SFX.select();
        renderChoices(pickUpgrades(3));
        rerollsEl.textContent = Player.rerolls|0;
        if(Player.rerolls<=0) rerollWrap.style.display='none';
      }else{
        SFX.deny();
      }
    };
  }

  // ------- Input -------
  const Keys = {};
  window.addEventListener('keydown', (e)=>{
    if(e.repeat) return;
    Keys[e.code]=true;
    if(e.code==='Space'){ G.input.pulse=true; e.preventDefault(); }
    if(e.code==='Escape'){ togglePause(); }
    if(e.code==='KeyM'){ SFX.enabled=!SFX.enabled; updateMenuStats(); }
  });
  window.addEventListener('keyup', (e)=>{ Keys[e.code]=false; });
  canvas.addEventListener('mousemove', (e)=>{ G.input.mouse.x=e.clientX; G.input.mouse.y=e.clientY; });
  canvas.addEventListener('mousedown', (e)=>{
    SFX.init();
    if(e.button===0){ G.input.mouse.left=true; G.input.attract=true; }
    if(e.button===2){ G.input.mouse.right=true; G.input.pulse=true; }
  });
  canvas.addEventListener('mouseup', (e)=>{
    if(e.button===0){ G.input.mouse.left=false; G.input.attract=false; }
    if(e.button===2){ G.input.mouse.right=false; }
  });
  canvas.addEventListener('contextmenu', e=>e.preventDefault());

  // Touch controls: Move to finger; buttons handle attract/pulse
  let primaryTouchId=null;
  window.addEventListener('touchstart', (e)=>{
    SFX.init();
    if(primaryTouchId===null && e.changedTouches.length>0){
      const t = e.changedTouches[0];
      primaryTouchId = t.identifier;
      G.input.touchMoveTarget = {x:t.clientX, y:t.clientY};
    }
  }, {passive:false});
  window.addEventListener('touchmove', (e)=>{
    for(const t of e.changedTouches){
      if(t.identifier===primaryTouchId){
        G.input.touchMoveTarget = {x:t.clientX, y:t.clientY};
        e.preventDefault();
      }
    }
  }, {passive:false});
  window.addEventListener('touchend', (e)=>{
    for(const t of e.changedTouches){
      if(t.identifier===primaryTouchId){
        primaryTouchId = null; G.input.touchMoveTarget = null;
      }
    }
  }, {passive:true});

  attractBtn.addEventListener('touchstart', e=>{ e.preventDefault(); G.input.attract=true; }, {passive:false});
  attractBtn.addEventListener('touchend', e=>{ e.preventDefault(); G.input.attract=false; }, {passive:false});
  pulseBtn.addEventListener('touchstart', e=>{ e.preventDefault(); G.input.pulse=true; }, {passive:false});

  attractBtn.addEventListener('mousedown', e=>{ G.input.attract=true; });
  attractBtn.addEventListener('mouseup', e=>{ G.input.attract=false; });
  pulseBtn.addEventListener('mousedown', e=>{ G.input.pulse=true; });

  // Buttons
  startBtn.onclick = ()=>{ startGame(); };
  metaBtn.onclick = ()=>{ openMeta(); };
  metaClose.onclick = ()=>{ closeMeta(); };
  metaReset.onclick = ()=>{ if(confirm('Reset all meta upgrades and cores?')){ META.reset(); } };
  soundBtn.onclick = ()=>{ SFX.enabled=!SFX.enabled; updateMenuStats(); };
  retryBtn.onclick = ()=>{ startGame(); };
  toMenuBtn.onclick = ()=>{ showMenu(); };
  toMetaBtn.onclick = ()=>{ openMeta(); };

  function openMeta(){ renderMeta(); metalab.classList.add('show'); menu.classList.remove('show'); gameover.classList.remove('show'); }
  function closeMeta(){ metalab.classList.remove('show'); if(G.state==='menu') menu.classList.add('show'); }

  // ------- Spawning -------
  function spawnShard(x, y, bonus=0){
    const s = {x,y, vx:(rand()*2-1)*30, vy:(rand()*2-1)*30, r:6, a:0, spin:(rand()*2-1)*2, t:0, val:1+bonus};
    G.entities.shards.push(s);
  }
  function spawnEnemy(type){
    // off-screen spawn
    const rEdge = (rand()*2<1);
    let x,y;
    if(rand()<0.5){ x = rand()<0.5? -30 : W+30; y = rand()*H; }
    else { y = rand()<0.5? -30 : H+30; x = rand()*W; }
    const base = {x,y, vx:0, vy:0, r: 14, hp:3, maxHp:3, type:'chaser', speed:90, mass:1, stun:0, a:0};
    if(type==='chaser'){
      base.type='chaser'; base.hp=2+G.wave*0.15; base.maxHp=base.hp; base.r=13; base.speed=100+G.wave*3; base.mass=1;
    } else if(type==='brute'){
      base.type='brute'; base.hp=6+G.wave*0.4; base.maxHp=base.hp; base.r=18; base.speed=70+G.wave*2; base.mass=2.2;
    } else if(type==='split'){
      base.type='split'; base.hp=1+G.wave*0.05; base.maxHp=base.hp; base.r=10; base.speed=120+G.wave*4; base.mass=0.8;
    }
    G.entities.enemies.push(base);
  }

  function spawnDrone(){
    const d = {angle: rand()*Math.PI*2, dist: 30 + 10*G.entities.drone?.length|0, speed: 2.4, r:6};
    G.entities.drones.push(d);
  }

  // ------- Collisions & Utility -------
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  const dist2 = (a,b)=>{ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; };
  const len = (x,y)=>Math.hypot(x,y);
  let shake=0;
  function screenShake(intensity){ shake = Math.min(20, shake+intensity); }

  // ------- Game Control -------
  function showMenu(){
    G.state='menu';
    menu.classList.add('show');
    gameover.classList.remove('show');
    levelup.classList.remove('show');
    updateMenuStats();
  }

  function startGame(){
    SFX.init();
    G.state='playing';
    menu.classList.remove('show'); gameover.classList.remove('show'); metalab.classList.remove('show');
    seed = (Math.random()*1e9)|0;
    G.t=0; G.dt=0; G.timescale=1;
    G.score=0; G.combo=1; G.comboTimer=0; G.wave=1;
    G.entities.enemies.length=0; G.entities.shards.length=0; G.entities.parts.length=0; G.entities.pulses.length=0; G.entities.drones.length=0;
    G.spawn.enemyTimer=0; G.spawn.shardTimer=0; G.spawn.waveTime=0; G.spawn.difficulty=0;
    Player.reset();
    for(let i=0;i<18;i++){ spawnShard(rand()*W, rand()*H); }
  }

  function endGame(){
    G.state='gameover';
    const coresGain = Math.floor(G.score/200);
    META.data.cores = (META.data.cores|0) + coresGain;
    META.save();
    gameover.classList.add('show');
    finalScoreEl.textContent = G.score|0;
    finalBestEl.textContent = G.best|0;
    finalCoresGainEl.textContent = coresGain|0;
    finalCoresEl.textContent = META.data.cores|0;
  }

  function togglePause(){
    if(G.state==='playing'){ G.state='pause'; }
    else if(G.state==='pause'){ G.state='playing'; }
  }

  // ------- Update & Render -------
  function update(dt){
    // time dilation
    let ts = 1;
    if(Player.slowTimer>0){ ts = 1/(1+Player.slowStrength); Player.slowTimer -= dt; }
    dt *= ts;

    // wave & spawns
    G.spawn.waveTime += dt;
    if(G.spawn.waveTime > 30){
      G.spawn.waveTime=0; G.wave++;
      waveEl.textContent = 'Wave ' + G.wave;
      // add spawn burst
      for(let i=0;i<3;i++){ spawnEnemy(['chaser','brute','split'][i%3]); }
    }

    // ensure shards
    G.spawn.shardTimer -= dt;
    const targetShards = 24 + Math.min(24, (G.wave-1)*2);
    if((G.entities.shards.length|0) < targetShards && G.spawn.shardTimer<=0){
      G.spawn.shardTimer = 0.12 + rand()*0.18;
      spawnShard(rand()*W, rand()*H);
    }

    // enemies
    G.spawn.enemyTimer -= dt;
    if(G.spawn.enemyTimer <= 0){
      const base = Math.max(0.4, 1.2 - G.wave*0.05);
      G.spawn.enemyTimer = base + rand()*0.6;
      const r = rand();
      const type = r<Math.min(0.6, 0.4+G.wave*0.02) ? 'chaser' : (r<0.85? 'split' : 'brute');
      spawnEnemy(type);
    }

    // input move
    let ax=0, ay=0;
    if(G.input.touchMoveTarget){
      const dx = G.input.touchMoveTarget.x - Player.x;
      const dy = G.input.touchMoveTarget.y - Player.y;
      const l = Math.hypot(dx,dy);
      if(l>4){ ax = dx/l; ay=dy/l; }
    }else{
      if(Keys['KeyW']||Keys['ArrowUp']) ay -= 1;
      if(Keys['KeyS']||Keys['ArrowDown']) ay += 1;
      if(Keys['KeyA']||Keys['ArrowLeft']) ax -= 1;
      if(Keys['KeyD']||Keys['ArrowRight']) ax += 1;
      const l = Math.hypot(ax,ay)||1; ax/=l; ay/=l;
    }
    // movement
    Player.vx += ax * Player.speed * dt;
    Player.vy += ay * Player.speed * dt;
    Player.vx *= Player.fric; Player.vy *= Player.fric;
    Player.x += Player.vx*dt; Player.y += Player.vy*dt;
    // bounds
    Player.x = clamp(Player.x, Player.r, W-Player.r);
    Player.y = clamp(Player.y, Player.r, H-Player.r);

    // attract input
    const attractActive = G.input.attract || G.input.mouse.left;
    // energy
    Player.energy = clamp(Player.energy + Player.energyRegen*dt, 0, Player.maxEnergy);

    // pulse input
    Player.pulseTimer -= dt;
    if((G.input.pulse || Keys['Space']) && Player.pulseTimer<=0){
      if(Player.energy >= Player.pulseCost){
        doPulse();
        Player.pulseTimer = Player.pulseCd;
        Player.energy -= Player.pulseCost;
      }else{
        SFX.deny();
      }
    }
    G.input.pulse=false; // tap

    // magnet effects
    const mR = Player.magnetR;
    const mR2 = mR*mR;
    if(attractActive && Player.energy>0){
      Player.energy = Math.max(0, Player.energy - 18*dt);
      // shards acceleration
      for(const s of G.entities.shards){
        const dx = Player.x - s.x; const dy = Player.y - s.y;
        const d2 = dx*dx+dy*dy;
        if(d2 < mR2){
          const d = Math.sqrt(d2)+0.0001;
          const f = (1 - d/mR) * Player.magnetForce;
          s.vx += (dx/d)*f*dt;
          s.vy += (dy/d)*f*dt;
        }
      }
      // enemies slight pull
      for(const e of G.entities.enemies){
        const dx = Player.x - e.x; const dy = Player.y - e.y;
        const d2 = dx*dx+dy*dy;
        if(d2 < mR2){
          const d = Math.sqrt(d2)+0.0001;
          const f = (1 - d/mR) * (Player.magnetForce*0.25) / e.mass;
          e.vx += (dx/d)*f*dt;
          e.vy += (dy/d)*f*dt;
        }
      }
    }

    // shards update & collect
    for(let i=G.entities.shards.length-1;i>=0;i--){
      const s = G.entities.shards[i];
      s.t += dt; s.a += s.spin*dt;
      s.vx *= 0.98; s.vy *= 0.98;
      s.x += s.vx*dt; s.y += s.vy*dt;
      // bounce
      if(s.x<s.r){ s.x=s.r; s.vx*=-0.6; }
      if(s.x>W-s.r){ s.x=W-s.r; s.vx*=-0.6; }
      if(s.y<s.r){ s.y=s.r; s.vy*=-0.6; }
      if(s.y>H-s.r){ s.y=H-s.r; s.vy*=-0.6; }
      // collect
      const dx= s.x-Player.x, dy=s.y-Player.y;
      if(dx*dx+dy*dy < (Player.r+10)*(Player.r+10)){
        collectShard(i, s);
      }else if(Player.drones>0){
        // drones collect nearby
        for(const d of G.entities.drones){
          const px = Player.x + Math.cos(d.angle)* (36 + 8*Player.drones);
          const py = Player.y + Math.sin(d.angle)* (36 + 8*Player.drones);
          const ddx=s.x-px, ddy=s.y-py;
          if(ddx*ddx+ddy*ddy < 18*18){
            collectShard(i,s); break;
          }
        }
      }
    }

    // enemies update
    for(let i=G.entities.enemies.length-1;i>=0;i--){
      const e = G.entities.enemies[i];
      e.a += dt*(0.8 + e.speed/200);
      // AI
      const dx = Player.x - e.x; const dy = Player.y - e.y;
      const d = Math.hypot(dx,dy)+0.0001;
      const dirx = dx/d, diry = dy/d;
      const acc = e.stun>0 ? 0 : e.speed;
      e.vx += dirx*acc*dt;
      e.vy += diry*acc*dt;
      // friction
      const drag = e.type==='brute'? 0.94: 0.96;
      e.vx *= drag; e.vy *= drag;
      e.x += e.vx*dt; e.y += e.vy*dt;
      e.stun = Math.max(0, e.stun - dt);
      // bounce arena
      if(e.x<e.r){ e.x=e.r; e.vx*=-0.8; }
      if(e.x>W-e.r){ e.x=W-e.r; e.vx*=-0.8; }
      if(e.y<e.r){ e.y=e.r; e.vy*=-0.8; }
      if(e.y>H-e.r){ e.y=H-e.r; e.vy*=-0.8; }
      // collide with player
      const pd2 = (e.x-Player.x)*(e.x-Player.x) + (e.y-Player.y)*(e.y-Player.y);
      if(pd2 < (e.r+Player.r)*(e.r+Player.r)){
        hitPlayer(i, e);
      }
      // cull insane outliers
      if(e.x<-100 || e.x>W+100 || e.y<-100 || e.y>H+100){ G.entities.enemies.splice(i,1); }
    }

    // pulses update (visual)
    for(let i=G.entities.pulses.length-1;i>=0;i--){
      const p = G.entities.pulses[i];
      p.t += dt;
      if(p.t>0.35) G.entities.pulses.splice(i,1);
    }

    // drones
    for(const d of G.entities.drones){
      d.angle += dt*d.speed;
    }

    // particles
    for(let i=G.entities.parts.length-1;i>=0;i--){
      const p = G.entities.parts[i];
      p.t += dt; p.x += p.vx*dt; p.y += p.vy*dt; p.vx *= 0.98; p.vy *= 0.98;
      if(p.t>p.life) G.entities.parts.splice(i,1);
    }

    // near-miss time slow
    if(Player.hasSlow){
      let near = false;
      for(const e of G.entities.enemies){
        const d = Math.hypot(e.x-Player.x, e.y-Player.y);
        if(d < Player.r + e.r + 14){ near=true; break; }
      }
      if(near){ Player.slowTimer = 0.08; }
    }

    // shields recharge
    if(Player.shieldMax>0){
      Player.shieldTimer += dt;
      if(Player.shieldTimer >= Player.shieldCd && Player.shield < Player.shieldMax){
        Player.shieldTimer=0; Player.shield++;
        // little pop
        spawnBurst(Player.x, Player.y, 8, '#7efcff');
      }
    }

    // level up progress
    if(Player.xp >= Player.toNext && G.state==='playing'){
      Player.xp -= Player.toNext;
      Player.level++;
      Player.toNext = Math.floor(Player.toNext*1.25 + 8);
      showLevelUp();
    }

    // combo decay
    if(G.comboTimer>0){ G.comboTimer -= dt; if(G.comboTimer<=0){ G.combo = Math.max(1, G.combo - 0.25); } }

    // shake decay
    shake *= 0.9;

    // HUD
    energyFill.style.width = (100*Player.energy/Player.maxEnergy).toFixed(1)+'%';
    xpFill.style.width = (100*Player.xp/Player.toNext).toFixed(1)+'%';
    updateHearts();
    scoreEl.textContent = G.score|0;
    multEl.textContent = 'x'+G.combo.toFixed(1)+' Combo';
  }

  function doPulse(){
    SFX.pulse(); screenShake(8);
    const ring = {x:Player.x, y:Player.y, r:Player.pulseRadius, t:0};
    G.entities.pulses.push(ring);
    for(let i=G.entities.enemies.length-1;i>=0;i--){
      const e = G.entities.enemies[i];
      const dx = e.x-Player.x, dy = e.y-Player.y;
      const d = Math.hypot(dx,dy)+0.0001;
      if(d < Player.pulseRadius){
        const f = (1 - d/Player.pulseRadius);
        const power = Player.pulsePower * f / e.mass;
        e.vx += (dx/d)*power;
        e.vy += (dy/d)*power;
        e.stun = Math.max(e.stun, 0.25+0.2*f);
        // dmg
        const dmg = 1 + 1.2*f;
        e.hp -= dmg;
        if(e.hp <= 0){
          killEnemy(i, e, true);
        }
      }
    }
    // pretty particles
    for(let i=0;i<26;i++){
      spawnParticle(Player.x, Player.y, (rand()*Math.PI*2), 160+rand()*160, '#8af5ff', 0.35, 2+rand()*2);
    }
  }

  function collectShard(i, s){
    G.entities.shards.splice(i,1);
    SFX.pickup();
    spawnSpark(s.x, s.y, '#7affd2');
    Player.energy = clamp(Player.energy + 6, 0, Player.maxEnergy);
    Player.xp += s.val;
    // scoring & combo
    const add = Math.floor(6 * G.combo);
    G.score += add;
    G.combo = Math.min(6, +(G.combo + 0.2).toFixed(2));
    G.comboTimer = 1.0; // seconds to keep combo
    // heal chance
    if(Player.healChance>0 && rand()<Player.healChance){
      Player.hp = Math.min(Player.maxHp, Player.hp+1);
      spawnSpark(Player.x, Player.y, '#8fff9c');
    }
  }

  function killEnemy(i, e, byPulse=false){
    // drop shards
    const drops = e.type==='brute'? 4 : (e.type==='split'? 1 : 2);
    for(let k=0;k<drops;k++){
      spawnShard(e.x + (rand()*2-1)*8, e.y + (rand()*2-1)*8);
    }
    spawnBurst(e.x, e.y, 12, e.type==='brute'?'#ff8b8b':'#ff6a9c');
    if(byPulse) screenShake(6);
    G.entities.enemies.splice(i,1);
    G.score += 8 + (e.type==='brute'? 6 : 0);
  }

  function hitPlayer(i, e){
    if(Player.invul>0) return;
    if(Player.shield>0){
      Player.shield--; Player.invul=0.3; SFX.hit(); screenShake(5);
      spawnBurst(Player.x, Player.y, 10, '#9ed1ff');
      // push enemy away
      const dx = e.x-Player.x, dy=e.y-Player.y, d=Math.hypot(dx,dy)+0.001;
      e.vx += (dx/d)*420; e.vy += (dy/d)*420; e.stun=0.35;
      return;
    }
    Player.hp -= 1;
    Player.invul = 1.0;
    SFX.hit(); screenShake(10);
    spawnBurst(Player.x, Player.y, 14, '#ff5f74');
    G.combo = Math.max(1, G.combo-0.8); G.comboTimer = 0.6;
    if(Player.hp<=0){
      // end
      if(G.score>G.best){ G.best=G.score; localStorage.setItem('mag_best', G.best|0); }
      endGame();
    }
  }

  function spawnParticle(x,y,angle,speed,color,life=0.6,size=2){
    const p = {x,y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, color, t:0, life, sz:size};
    G.entities.parts.push(p);
  }
  function spawnBurst(x,y,n,color){
    for(let i=0;i<n;i++){
      spawnParticle(x,y, rand()*Math.PI*2, 40+rand()*220, color, 0.5+rand()*0.5, 1.5+rand()*2.5);
    }
  }
  function spawnSpark(x,y,color){
    spawnParticle(x,y, rand()*Math.PI*2, 60+rand()*100, color, 0.35+rand()*0.2, 2);
  }

  function updateHearts(){
    const hearts = [];
    for(let i=0;i<Player.maxHp;i++){
      hearts.push(`<div class="heart" style="opacity:${i<Player.hp?1:.25}"></div>`);
    }
    heartsEl.innerHTML = hearts.join('');
  }

  function render(){
    // background
    const t = performance.now()*0.001;
    ctx.clearRect(0,0,W,H);
    // vignette
    const grad = ctx.createRadialGradient(CX, CY, 0, CX, CY, Math.max(W,H)*0.8);
    grad.addColorStop(0, '#0d1430');
    grad.addColorStop(1, '#070a12');
    ctx.fillStyle = grad; ctx.fillRect(0,0,W,H);

    // grid
    ctx.save();
    const gx = (t*20)%40, gy=(t*14)%40;
    ctx.globalAlpha = 0.15;
    ctx.strokeStyle = '#0f1832';
    ctx.lineWidth = 1;
    for(let x=(gx|0); x<W; x+=40){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=(gy|0); y<H; y+=40){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
    ctx.restore();

    // shake
    if(shake>0){ ctx.save(); ctx.translate((rand()*2-1)*shake, (rand()*2-1)*shake); }

    // magnet ring visual
    const attractActive = G.input.attract || G.input.mouse.left;
    if(attractActive && Player.energy>0){
      ctx.beginPath();
      ctx.arc(Player.x, Player.y, Player.magnetR, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(120,235,255,0.12)';
      ctx.lineWidth = 2; ctx.setLineDash([6,8]); ctx.stroke(); ctx.setLineDash([]);
    }

    // shards
    for(const s of G.entities.shards){
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.a);
      const g = ctx.createLinearGradient(-s.r, -s.r, s.r, s.r);
      g.addColorStop(0, 'rgba(90,255,169,0.9)');
      g.addColorStop(1, 'rgba(100,255,220,0.9)');
      ctx.fillStyle = g;
      ctx.shadowColor = '#59ffb2'; ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.moveTo(0,-s.r); ctx.lineTo(s.r,0); ctx.lineTo(0,s.r); ctx.lineTo(-s.r,0); ctx.closePath();
      ctx.fill();
      ctx.restore();
      // magnet tether line
      if(attractActive){
        const dx=s.x-Player.x, dy=s.y-Player.y, d=Math.hypot(dx,dy);
        if(d<Player.magnetR*0.75){
          ctx.strokeStyle = 'rgba(120,235,255,0.15)'; ctx.lineWidth=1;
          ctx.beginPath(); ctx.moveTo(Player.x,Player.y); ctx.lineTo(s.x,s.y); ctx.stroke();
        }
      }
    }

    // pulses
    for(const p of G.entities.pulses){
      const prog = p.t/0.35;
      const r = p.r * prog;
      const alpha = 0.35*(1-prog);
      ctx.beginPath();
      ctx.arc(p.x, p.y, r, 0, Math.PI*2);
      ctx.strokeStyle = `rgba(133,218,255,${alpha})`;
      ctx.lineWidth = 6*(1-prog);
      ctx.stroke();
    }

    // enemies
    for(const e of G.entities.enemies){
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.rotate(Math.atan2(e.vy, e.vx));
      ctx.shadowBlur = 12; ctx.shadowColor = '#ff7aa4';
      if(e.type==='chaser'){
        ctx.fillStyle = '#ff6ab2';
        ctx.beginPath();
        ctx.moveTo(e.r,0); ctx.lineTo(-e.r*0.7, -e.r*0.6); ctx.lineTo(-e.r*0.7, e.r*0.6); ctx.closePath();
        ctx.fill();
      } else if(e.type==='brute'){
        ctx.fillStyle = '#ff5f74';
        ctx.beginPath();
        ctx.rect(-e.r*0.9, -e.r*0.9, e.r*1.8, e.r*1.8);
        ctx.fill();
      } else {
        ctx.fillStyle = '#ff8ecf';
        ctx.beginPath();
        ctx.arc(0,0,e.r,0,Math.PI*2); ctx.fill();
      }
      ctx.restore();
      // hp bar
      if(e.maxHp>2){
        const w= e.r*2, h=3;
        ctx.fillStyle='rgba(255,255,255,.15)'; ctx.fillRect(e.x-w/2, e.y-e.r-10, w, h);
        ctx.fillStyle='#ff7999'; ctx.fillRect(e.x-w/2, e.y-e.r-10, w*(e.hp/e.maxHp), h);
      }
    }

    // drones
    for(const d of G.entities.drones){
      const px = Player.x + Math.cos(d.angle)*(36 + 8*Player.drones);
      const py = Player.y + Math.sin(d.angle)*(36 + 8*Player.drones);
      ctx.fillStyle='#9de8ff'; ctx.shadowColor='#9de8ff'; ctx.shadowBlur=10;
      ctx.beginPath(); ctx.arc(px,py,d.r,0,Math.PI*2); ctx.fill();
    }

    // player
    ctx.save();
    ctx.translate(Player.x, Player.y);
    const grad2 = ctx.createRadialGradient(0,0,2, 0,0, Player.r+6);
    grad2.addColorStop(0, '#c6e7ff');
    grad2.addColorStop(1, '#65c7ff');
    ctx.fillStyle = grad2; ctx.shadowColor='#65c7ff'; ctx.shadowBlur=20;
    ctx.beginPath(); ctx.arc(0,0, Player.r, 0, Math.PI*2); ctx.fill();
    // shield halo
    if(Player.shield>0){
      ctx.beginPath(); ctx.arc(0,0, Player.r+6, 0, Math.PI*2);
      ctx.strokeStyle='rgba(158,209,255,.7)'; ctx.lineWidth=3; ctx.stroke();
    }
    // invul blink
    if(Player.invul>0){
      Player.invul -= G.dt;
      ctx.beginPath(); ctx.arc(0,0, Player.r+2, 0, Math.PI*2);
      ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.lineWidth=1.5; ctx.setLineDash([4,4]); ctx.stroke(); ctx.setLineDash([]);
    }
    ctx.restore();

    // particles
    for(const p of G.entities.parts){
      const a = 1 - p.t/p.life;
      ctx.fillStyle = hexToRgba(p.color, a);
      ctx.beginPath(); ctx.arc(p.x, p.y, p.sz, 0, Math.PI*2); ctx.fill();
    }

    if(shake>0){ ctx.restore(); }
  }

  function hexToRgba(hex, a){
    // #rrggbb
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    return `rgba(${r},${g},${b},${a})`;
  }

  // ------- Main Loop -------
  function frame(t){
    if(!G.last) G.last = t;
    let dt = Math.min(0.033, (t - G.last)/1000);
    G.last = t;
    G.dt = dt;
    if(G.state==='playing'){ update(dt); }
    render();
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);

  // ------- Initialize menu stats -------
  updateMenuStats();
  showMenu();

})();
</script>
</body>
</html>